{\rtf1\ansi\ansicpg1252\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 CourierNewPSMT;}
{\colortbl;\red255\green255\blue255;\red191\green100\blue38;\red32\green32\blue32;\red153\green168\blue186;
\red160\green0\blue163;\red128\green63\blue122;\red86\green132\blue173;\red109\green109\blue109;\red254\green187\blue91;
\red117\green114\blue185;\red95\green96\blue103;\red88\green118\blue71;}
{\*\expandedcolortbl;;\cssrgb\c80000\c47059\c19608;\cssrgb\c16863\c16863\c16863;\cssrgb\c66275\c71765\c77647;
\cssrgb\c69804\c0\c69804;\cssrgb\c58039\c33333\c55294;\cssrgb\c40784\c59216\c73333;\cssrgb\c50196\c50196\c50196;\cssrgb\c100000\c77647\c42745;
\cssrgb\c53333\c53333\c77647;\cssrgb\c44706\c45098\c47843;\cssrgb\c41569\c52941\c34902;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx7876\tx7876\tx7876\tx7876\tx7876\tx7876\tx7876\tx7876\pardeftab720\li270\ri656\partightenfactor0

\f0\fs20 \cf2 \cb3 import \cf4 cv2\uc0\u8232 \cf2 import \cf4 mediapipe \cf2 as \cf4 mp\uc0\u8232 \cf2 import \cf4 time\uc0\u8232 \cf2 import \cf4 math\uc0\u8232 \cf2 import \cf4 numpy \cf2 as \cf4 np\uc0\u8232 \u8232 \cf2 class \cf4 handDetector():\uc0\u8232     \cf2 def \cf5 __init__\cf4 (\cf6 self\cf2 ,\cf4 mode=\cf2 False,\cf4 maxHands=\cf7 2\cf2 ,\cf4 detectionCon=\cf7 0.5\cf2 ,\cf4 trackCon=\cf7 0.5\cf4 ):\cf8 #constructor\uc0\u8232         \cf6 self\cf4 .mode=mode \uc0\u8232         \cf6 self\cf4 .maxHands=maxHands\uc0\u8232         \cf6 self\cf4 .detectionCon=detectionCon\uc0\u8232         \cf6 self\cf4 .trackCon=trackCon\uc0\u8232         \cf6 self\cf4 .mpHands=mp.solutions.hands\cf8 #initializing hands module for the instance\uc0\u8232         \cf6 self\cf4 .hands=\cf6 self\cf4 .mpHands.Hands(\cf6 self\cf4 .mode\cf2 ,\cf6 self\cf4 .maxHands\cf2 ,\cf6 self\cf4 .detectionCon\cf2 ,\cf6 self\cf4 .trackCon) \cf8 #object for Hands for a particular instance\uc0\u8232         \cf6 self\cf4 .mpDraw=mp.solutions.drawing_utils\cf8 #object for Drawing\uc0\u8232         \cf6 self\cf4 .tipIds = [\cf7 4\cf2 , \cf7 8\cf2 , \cf7 12\cf2 , \cf7 16\cf2 , \cf7 20\cf4 ]\uc0\u8232 \u8232     \cf2 def \cf9 findHands\cf4 (\cf6 self\cf2 ,\cf4 img\cf2 ,\cf4 draw=\cf2 True\cf4 ):\uc0\u8232         imgRGB=cv2.cvtColor(img\cf2 ,\cf4 cv2.COLOR_BGR2RGB)\cf8 #converting to RGB bcoz hand recognition works only on RGB image\uc0\u8232         \cf6 self\cf4 .results=\cf6 self\cf4 .hands.process(imgRGB)\cf8 #processing the RGB image \uc0\u8232         \cf2 if \cf6 self\cf4 .results.multi_hand_landmarks:\cf8 # gives x,y,z of every landmark or if no hand than NONE\uc0\u8232             \cf2 for \cf4 handLms \cf2 in \cf6 self\cf4 .results.multi_hand_landmarks:\cf8 #each hand landmarks in results\uc0\u8232                 \cf2 if \cf4 draw:\uc0\u8232                      \cf6 self\cf4 .mpDraw.draw_landmarks(img\cf2 ,\cf4 handLms\cf2 ,\cf6 self\cf4 .mpHands.HAND_CONNECTIONS)\cf8 #joining points on our hand\uc0\u8232         \u8232         \cf2 return \cf4 img\uc0\u8232 \u8232     \cf2 def \cf9 findPosition\cf4 (\cf6 self\cf2 ,\cf4 img\cf2 ,\cf4 handNo=\cf7 0\cf2 ,\cf4 draw=\cf2 True\cf4 ):\uc0\u8232         xList=[]\u8232         yList=[]\u8232         bbox=[]\u8232         \cf6 self\cf4 .lmlist=[]\uc0\u8232         \cf2 if \cf6 self\cf4 .results.multi_hand_landmarks:\cf8 # gives x,y,z of every landmark    \uc0\u8232             \cf4 myHand=\cf6 self\cf4 .results.multi_hand_landmarks[handNo]\cf8 #Gives result for particular hand \uc0\u8232             \cf2 for \cf4 id\cf2 ,\cf4 lm \cf2 in \cf10 enumerate\cf4 (myHand.landmark):\cf8 #gives id and lm(x,y,z)\uc0\u8232                 \cf4 h\cf2 ,\cf4 w\cf2 ,\cf4 c=img.shape\cf8 #getting h,w for converting decimals x,y into pixels \uc0\u8232                 \cf4 cx\cf2 ,\cf4 cy=\cf10 int\cf4 (lm.x*w)\cf2 ,\cf10 int\cf4 (lm.y*h)\cf8 # pixels coordinates for landmarks\uc0\u8232                 # print(id, cx, cy)\u8232                 \cf4 xList.append(cx)\uc0\u8232                 yList.append(cy)\u8232                 \cf6 self\cf4 .lmlist.append([id\cf2 ,\cf4 cx\cf2 ,\cf4 cy])\uc0\u8232                 \cf2 if \cf4 draw:\uc0\u8232                     cv2.circle(img\cf2 ,\cf4 (cx\cf2 ,\cf4 cy)\cf2 ,\cf7 5\cf2 ,\cf4 (\cf7 255\cf2 ,\cf7 0\cf2 ,\cf7 255\cf4 )\cf2 ,\cf4 cv2.FILLED)    \uc0\u8232             xmin\cf2 ,\cf4 xmax=\cf10 min\cf4 (xList)\cf2 ,\cf10 max\cf4 (xList)\uc0\u8232             ymin\cf2 ,\cf4 ymax=\cf10 min\cf4 (yList)\cf2 ,\cf10 max\cf4 (yList)\uc0\u8232             bbox=xmin\cf2 ,\cf4 ymin\cf2 ,\cf4 xmax\cf2 ,\cf4 ymax\uc0\u8232 \u8232             \cf2 if \cf4 draw:\uc0\u8232                 cv2.rectangle(img\cf2 ,\cf4 (bbox[\cf7 0\cf4 ]-\cf7 20\cf2 ,\cf4 bbox[\cf7 1\cf4 ]-\cf7 20\cf4 )\cf2 ,\cf4 (bbox[\cf7 2\cf4 ]+\cf7 20\cf2 ,\cf4 bbox[\cf7 3\cf4 ]+\cf7 20\cf4 )\cf2 ,\cf4 (\cf7 0\cf2 ,\cf7 255\cf2 ,\cf7 0\cf4 )\cf2 ,\cf7 2\cf4 )\uc0\u8232 \u8232         \cf2 return \cf6 self\cf4 .lmlist\cf2 ,\cf4 bbox\uc0\u8232 \u8232     \cf2 def \cf9 fingersUp\cf4 (\cf6 self\cf4 ):\cf8 #checking which finger is open \uc0\u8232         \cf4 fingers = []\cf8 #storing final result\uc0\u8232         # Thumb < sign only when  we use flip function to avoid mirror inversion else > sign\u8232         \cf2 if \cf6 self\cf4 .lmlist[\cf6 self\cf4 .tipIds[\cf7 0\cf4 ]][\cf7 1\cf4 ] > \cf6 self\cf4 .lmlist[\cf6 self\cf4 .tipIds[\cf7 0\cf4 ] - \cf7 1\cf4 ][\cf7 1\cf4 ]:\cf8 #checking x position of 4 is in right to x position of 3\uc0\u8232             \cf4 fingers.append(\cf7 1\cf4 )\uc0\u8232         \cf2 else\cf4 :\uc0\u8232             fingers.append(\cf7 0\cf4 )\uc0\u8232 \u8232         \cf8 # Fingers\uc0\u8232         \cf2 for \cf4 id \cf2 in \cf10 range\cf4 (\cf7 1\cf2 , \cf7 5\cf4 ):\cf8 #checking tip point is below tippoint-2 (only in Y direction)\uc0\u8232             \cf2 if \cf6 self\cf4 .lmlist[\cf6 self\cf4 .tipIds[id]][\cf7 2\cf4 ] < \cf6 self\cf4 .lmlist[\cf6 self\cf4 .tipIds[id] - \cf7 2\cf4 ][\cf7 2\cf4 ]:\uc0\u8232                 fingers.append(\cf7 1\cf4 )\uc0\u8232             \cf2 else\cf4 :\uc0\u8232                 fingers.append(\cf7 0\cf4 )\uc0\u8232 \u8232             \cf8 # totalFingers = fingers.count(1)\uc0\u8232 \u8232         \cf2 return \cf4 fingers\uc0\u8232 \u8232 \u8232 \u8232 \cf2 def \cf9 main\cf4 ():\uc0\u8232 \u8232     PTime=\cf7 0\cf8 # previous time\uc0\u8232     \cf11 CTime\cf4 =\cf7 0\cf8 # current time\uc0\u8232     \cf4 cap=cv2.VideoCapture(\cf7 0\cf4 )\uc0\u8232     detector=handDetector()\u8232 \u8232     \cf2 while True\cf4 :\uc0\u8232         success\cf2 ,\cf4 img=cap.read()\cf8 #T or F,frame\uc0\u8232         \cf4 img =detector.findHands(img)\uc0\u8232         lmlist\cf2 ,\cf4 bbox= detector.findPosition(img)\uc0\u8232         \cf2 if \cf10 len\cf4 (lmlist)!=\cf7 0\cf4 :\uc0\u8232             \cf10 print\cf4 (lmlist[\cf7 4\cf4 ])\uc0\u8232 \u8232         CTime=time.time()\cf8 #current time\uc0\u8232         \cf4 fps=\cf7 1\cf4 /(CTime-PTime)\cf8 #FPS\uc0\u8232         \cf4 PTime=CTime\cf8 #previous time is replaced by current time\uc0\u8232 \u8232         \cf4 cv2.putText(img\cf2 ,\cf10 str\cf4 (\cf10 int\cf4 (fps))\cf2 ,\cf4 (\cf7 10\cf2 ,\cf7 70\cf4 )\cf2 ,\cf4 cv2.FONT_HERSHEY_COMPLEX\cf2 ,\cf7 3\cf2 ,\cf4 (\cf7 255\cf2 ,\cf7 0\cf2 ,\cf7 255\cf4 )\cf2 ,\cf7 3\cf4 )\cf8 # showing Fps on screen\uc0\u8232 \u8232 \u8232         \cf4 cv2.imshow(\cf12 "Image"\cf2 ,\cf4 img)\cf8 #showing img not imgRGB\uc0\u8232         \cf4 cv2.waitKey(\cf7 1\cf4 )\uc0\u8232 \u8232 \u8232 \cf2 if \cf4 __name__==\cf12 "__main__"\cf4 :\uc0\u8232     main()\
}